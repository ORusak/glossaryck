# Отладка
## Подключение к работающему сервису
* Требуется отправить signal SIGUSR1 процессу node. Это переведет сервис в режим отладки.
    * Дальше chrome://inspect сам подключится к заданному порту
## Подключение к сервису запущенному в режиме отладки
* запуск node --inspect=2000 hello.js
* VSCode
  * Command: Auto attach
  * `{
            "type": "node",
            "request": "attach",
            "name": "Attach",
            "port": 9229,
            "restart": true
    }`

## Отключение
* Похоже функции отключения режима отладки нет. Если убить процесс дебаггера умирает и процесс сервиса

# Анализ производительности
* Анализ через запись Profile в chrome://inspect
    * Не понятно насколько это удобно под нагрузкой и как найти тот подпроцесс что тормозит
* Профилирование средствами nodejs. 
    * Запуск сервера с ключом -prof
    * получение лога
    * обработка лога и последующий анализ node --prof-process isolate-0xnnnnnnnnnnnn-v8.log > processed.txt
* Анализ неоптимизированных функций
    * Запуск с ключами --trace-deopt --trace-opt
    * Получаем лог, смотрим какие части кода были не оптимизированы v8 и почему.
* Использование утилит node-clinic

# Анализ утечек памяти
* Запись в chrome://inspect memoryheap и просмотр занимаемой памяти
    * Поиск через анализ дерева зависимостей или диаграммы временной. Находим функции которые занимают большой объем 
    и смотрим что у них в зависимостях.
* Можно записать heap отдельно через модуль https://www.npmjs.com/package/heapdump и проанализировать в chrome://inspect.
Однако это не так эффективно так как в момент записи могут не быть пиков набора памяти.
* Использование утилит node-clinic
